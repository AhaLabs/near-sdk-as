"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const transformRange_1 = require("visitor-as/dist/transformRange");
const common_1 = require("./common");
const utils_1 = require("./utils");
class ClassExporter extends visitor_as_1.ClassDecorator {
    sb = [];
    static classSeen;
    static hasConstructor;
    static get className() {
        return utils_1.toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (utils_1.toString(member.name) === name) {
                    throw new Error(`Method "${utils_1.toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error("Exported Singleton class cannot have properties. Found " +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, common_1.PRIVATE_DECORATOR)
            ? `__assertPrivate();`
            : "";
        let name = utils_1.toString(node.name);
        let decorators = (node.decorators || []).map(utils_1.toString);
        let returnType = utils_1.toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return utils_1.toString(param);
        });
        let pramNames = origParams.map((param) => {
            return utils_1.toString(param.name);
        });
        let isInit = name === "constructor";
        let assertStr = "";
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === "void";
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(", ")});`
            : `${!isVoid ? "let res =  " : ""}__contract.${name}(${pramNames.join(", ")});`;
        if (isInit) {
            name = "init";
            parameters = origParams.map((node) => `${utils_1.toString(node.name)}: ${utils_1.toString(node.type)}${node.initializer ? " = " + utils_1.toString(node.initializer) : ""}`);
            returnType = "void";
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes("exportAs"))) {
                decorators.push(`@exportAs("new")`);
                this.checkMethods("new");
            }
            else {
                let decorator = node.decorators.find((d) => utils_1.toString(d.name) === "exportAs");
                if (decorator.args.length == 1) {
                    this.checkMethods(utils_1.toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes("mutateState");
            return res;
        });
        this.sb.push(`${decorators.join("\n")}
export function ${name}(${parameters.join(", ")}): ${returnType} {
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ""}
  ${isVoid || isInit ? "" : "return res;"}
}`);
    }
    visitClassDeclaration(node) {
        if (node.is(as_1.CommonFlags.EXPORT)) {
            let name = utils_1.toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return utils_1.toString(member.name) === "constructor";
                }
                return false;
            });
            this.sb.push(`let __contract: ${name};`);
            this.sb.push(`if (__checkState()) {
  __contract = __getState<${name}>();
}${!ClassExporter.hasConstructor
                ? ` else {
  __contract = new ${name}();
}`
                : ""}`);
            this.visit(node.members);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            // console.log(this.sb.join("\n"));
            let newStatements = this.sb.map(common_1.parseTopLevelStatements).flat().map((s) => transformRange_1.RangeTransform.visit(s, node));
            // console.log(newStatements.map(toString))
            let statements = newStatements.map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...statements);
            // console.log(toString(node.range.source));
        }
    }
    get name() {
        return "nearBindgen";
    }
    visitSource(node) {
        if (node.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        console.log(node.internalPath);
        super.visitSource(node);
    }
    static visit(sources) {
        let visitor = new ClassExporter();
        visitor.visit(sources);
        return sources;
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVN1QjtBQUN2QiwyQ0FBbUQ7QUFDbkQsbUVBQWdFO0FBQ2hFLHFDQUErRTtBQUMvRSxtQ0FBbUM7QUFFbkMsTUFBYSxhQUFjLFNBQVEsMkJBQWM7SUFDL0MsRUFBRSxHQUFhLEVBQUUsQ0FBQztJQUNsQixNQUFNLENBQUMsU0FBUyxDQUFtQjtJQUNuQyxNQUFNLENBQUMsY0FBYyxDQUFVO0lBRS9CLE1BQU0sS0FBSyxTQUFTO1FBQ2xCLE9BQU8sZ0JBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxZQUFZLENBQUMsSUFBWTtRQUN2QixJQUFJLE1BQU0sR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDaEMsSUFDRSxNQUFNLFlBQVksc0JBQWlCO2dCQUNuQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxPQUFPLENBQUMsRUFDL0I7Z0JBQ0EsSUFBSSxnQkFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxnQkFBUSxDQUNqQixNQUFNLENBQUMsSUFBSSxDQUNaLGdFQUFnRSxDQUNsRSxDQUFDO2lCQUNIO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxxQkFBcUIsQ0FBQyxJQUFzQixJQUFTLENBQUM7SUFFdEQsc0JBQXNCLENBQUMsSUFBdUI7UUFDNUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFB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QUFPLENBQUMsQ0FBQztRQUN2QixPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0NBQ0Y7QUExS0Qsc0NBMEtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2xhc3NEZWNsYXJhdGlvbixcbiAgRmllbGREZWNsYXJhdGlvbixcbiAgTWV0aG9kRGVjbGFyYXRpb24sXG4gIFNvdXJjZSxcbiAgQ29tbW9uRmxhZ3MsXG4gIFNvdXJjZUtpbmQsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIEJsb2NrU3RhdGVtZW50LFxufSBmcm9tIFwidmlzaXRvci1hcy9hc1wiO1xuaW1wb3J0IHsgdXRpbHMsIENsYXNzRGVjb3JhdG9yIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcbmltcG9ydCB7IFJhbmdlVHJhbnNmb3JtIH0gZnJvbSBcInZpc2l0b3ItYXMvZGlzdC90cmFuc2Zvcm1SYW5nZVwiO1xuaW1wb3J0IHsgaXNFbnRyeSwgcGFyc2VUb3BMZXZlbFN0YXRlbWVudHMsIFBSSVZBVEVfREVDT1JBVE9SIH0gZnJvbSBcIi4vY29tbW9uXCI7XG5pbXBvcnQgeyB0b1N0cmluZyB9IGZyb20gXCIuL3V0aWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBDbGFzc0V4cG9ydGVyIGV4dGVuZHMgQ2xhc3NEZWNvcmF0b3Ige1xuICBzYjogc3RyaW5nW10gPSBbXTtcbiAgc3RhdGljIGNsYXNzU2VlbjogQ2xhc3NEZWNsYXJhdGlvbjtcbiAgc3RhdGljIGhhc0NvbnN0cnVjdG9yOiBib29sZWFuO1xuXG4gIHN0YXRpYyBnZXQgY2xhc3NOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvU3RyaW5nKENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuLm5hbWUpO1xuICB9XG5cbiAgY2hlY2tNZXRob2RzKG5hbWU6IHN0cmluZykge1xuICAgIGxldCBfY2xhc3MgPSBDbGFzc0V4cG9ydGVyLmNsYXNzU2VlbjtcbiAgICBfY2xhc3MubWVtYmVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgbWVtYmVyIGluc3RhbmNlb2YgTWV0aG9kRGVjbGFyYXRpb24gJiZcbiAgICAgICAgIW1lbWJlci5pcyhDb21tb25GbGFncy5QUklWQVRFKVxuICAgICAgKSB7XG4gICAgICAgIGlmICh0b1N0cmluZyhtZW1iZXIubmFtZSkgPT09IG5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTWV0aG9kIFwiJHt0b1N0cmluZyhcbiAgICAgICAgICAgICAgbWVtYmVyLm5hbWVcbiAgICAgICAgICAgICl9XCIgYWxyZWFkeSB1c2VkOyBjYW5ub3QgZXhwb3J0IGNvbnN0cnVjdG9yIHVzaW5nIHRoZSBzYW1lIG5hbWUuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZpc2l0RmllbGREZWNsYXJhdGlvbihub2RlOiBGaWVsZERlY2xhcmF0aW9uKTogdm9pZCB7fVxuXG4gIHZpc2l0TWV0aG9kRGVjbGFyYXRpb24obm9kZTogTWV0aG9kRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAobm9kZS5pcyhDb21tb25GbGFncy5TRVQpIHx8IG5vZGUuaXMoQ29tbW9uRmxhZ3MuR0VUKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkV4cG9ydGVkIFNpbmdsZXRvbiBjbGFzcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzLiBGb3VuZCBcIiArXG4gICAgICAgICAgbm9kZS5uYW1lLnRleHRcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFByaXZhdGUgbWV0aG9kcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICBpZiAobm9kZS5pcyhDb21tb25GbGFncy5QUklWQVRFKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJpdmF0ZUNoZWNrID0gdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIFBSSVZBVEVfREVDT1JBVE9SKVxuICAgICAgPyBgX19hc3NlcnRQcml2YXRlKCk7YFxuICAgICAgOiBcIlwiO1xuICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IChub2RlLmRlY29yYXRvcnMgfHwgW10pLm1hcCh0b1N0cmluZyk7XG4gICAgbGV0IHJldHVyblR5cGUgPSB0b1N0cmluZyhub2RlLnNpZ25hdHVyZS5yZXR1cm5UeXBlKTtcbiAgICBsZXQgb3JpZ1BhcmFtcyA9IG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubWFwKHV0aWxzLmNsb25lTm9kZSk7XG4gICAgbGV0IHBhcmFtZXRlcnMgPSBvcmlnUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgIGlmIChwYXJhbS5pbXBsaWNpdEZpZWxkRGVjbGFyYXRpb24pIHtcbiAgICAgICAgcGFyYW0ubmFtZS50ZXh0ID0gcGFyYW0ubmFtZS50ZXh0LnN1YnN0cmluZygyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1N0cmluZyhwYXJhbSk7XG4gICAgfSk7XG4gICAgbGV0IHByYW1OYW1lcyA9IG9yaWdQYXJhbXMubWFwKChwYXJhbSkgPT4ge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgIH0pO1xuICAgIGxldCBpc0luaXQgPSBuYW1lID09PSBcImNvbnN0cnVjdG9yXCI7XG4gICAgbGV0IGFzc2VydFN0cjogc3RyaW5nID0gXCJcIjtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KGlzTnVsbChfX2NvbnRyYWN0KSwgXCJjb250cmFjdCBpcyBhbHJlYWR5IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfSBlbHNlIGlmIChDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yKSB7XG4gICAgICBhc3NlcnRTdHIgPSBgYXNzZXJ0KCFpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgbm90IGluaXRpYWxpemVkXCIpO2A7XG4gICAgfVxuICAgIGxldCBpc1ZvaWQgPSByZXR1cm5UeXBlID09PSBcInZvaWRcIjtcbiAgICBsZXQgYm9keSA9IGlzSW5pdFxuICAgICAgPyBgX19jb250cmFjdCA9IG5ldyAke0NsYXNzRXhwb3J0ZXIuY2xhc3NOYW1lfSgke3ByYW1OYW1lcy5qb2luKFwiLCBcIil9KTtgXG4gICAgICA6IGAkeyFpc1ZvaWQgPyBcImxldCByZXMgPSAgXCIgOiBcIlwifV9fY29udHJhY3QuJHtuYW1lfSgke3ByYW1OYW1lcy5qb2luKFxuICAgICAgICAgIFwiLCBcIlxuICAgICAgICApfSk7YDtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBuYW1lID0gXCJpbml0XCI7XG4gICAgICBwYXJhbWV0ZXJzID0gb3JpZ1BhcmFtcy5tYXAoXG4gICAgICAgIChub2RlKSA9PlxuICAgICAgICAgIGAke3RvU3RyaW5nKG5vZGUubmFtZSl9OiAke3RvU3RyaW5nKG5vZGUudHlwZSl9JHtcbiAgICAgICAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPyBcIiA9IFwiICsgdG9TdHJpbmcobm9kZS5pbml0aWFsaXplcikgOiBcIlwiXG4gICAgICAgICAgfWBcbiAgICAgICk7XG4gICAgICByZXR1cm5UeXBlID0gXCJ2b2lkXCI7XG4gICAgfVxuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIGlmICghZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IGRlY29yYXRvci5pbmNsdWRlcyhcImV4cG9ydEFzXCIpKSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2goYEBleHBvcnRBcyhcIm5ld1wiKWApO1xuICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcyhcIm5ld1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBkZWNvcmF0b3IgPSBub2RlLmRlY29yYXRvcnMhLmZpbmQoXG4gICAgICAgICAgKGQpID0+IHRvU3RyaW5nKGQubmFtZSkgPT09IFwiZXhwb3J0QXNcIlxuICAgICAgICApITtcbiAgICAgICAgaWYgKGRlY29yYXRvci5hcmdzIS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHRoaXMuY2hlY2tNZXRob2RzKHRvU3RyaW5nKGRlY29yYXRvci5hcmdzIVswXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhc011dGF0ZVN0YXRlID0gZGVjb3JhdG9ycy5zb21lKChkZWNvcmF0b3IpID0+IHtcbiAgICAgIGxldCByZXMgPSBkZWNvcmF0b3IuaW5jbHVkZXMoXCJtdXRhdGVTdGF0ZVwiKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgdGhpcy5zYi5wdXNoKFxuICAgICAgYCR7ZGVjb3JhdG9ycy5qb2luKFwiXFxuXCIpfVxuZXhwb3J0IGZ1bmN0aW9uICR7bmFtZX0oJHtwYXJhbWV0ZXJzLmpvaW4oXCIsIFwiKX0pOiAke3JldHVyblR5cGV9IHtcbiAgJHtwcml2YXRlQ2hlY2t9XG4gICR7YXNzZXJ0U3RyfVxuICAke2JvZHl9XG4gICR7aXNJbml0IHx8IGhhc011dGF0ZVN0YXRlID8gYF9fc2V0U3RhdGUoX19jb250cmFjdCk7YCA6IFwiXCJ9XG4gICR7aXNWb2lkIHx8IGlzSW5pdCA/IFwiXCIgOiBcInJldHVybiByZXM7XCJ9XG59YFxuICAgICk7XG4gIH1cblxuICB2aXNpdENsYXNzRGVjbGFyYXRpb24obm9kZTogQ2xhc3NEZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGlmIChub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCkpIHtcbiAgICAgIGxldCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmIChDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBleHBvcnQgY2xhc3MgJHtuYW1lfS4gJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0gYWxyZWFkeSBleHBvcnRlZC4gYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4gPSBub2RlO1xuICAgICAgQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3RvciA9IG5vZGUubWVtYmVycy5zb21lKChtZW1iZXIpID0+IHtcbiAgICAgICAgaWYgKG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKG1lbWJlci5uYW1lKSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zYi5wdXNoKGBsZXQgX19jb250cmFjdDogJHtuYW1lfTtgKTtcbiAgICAgIHRoaXMuc2IucHVzaChcbmBpZiAoX19jaGVja1N0YXRlKCkpIHtcbiAgX19jb250cmFjdCA9IF9fZ2V0U3RhdGU8JHtuYW1lfT4oKTtcbn0ke1xuICAgICAgICAgICFDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yXG4gICAgICAgICAgICA/IGAgZWxzZSB7XG4gIF9fY29udHJhY3QgPSBuZXcgJHtuYW1lfSgpO1xufWBcbiAgICAgICAgICAgIDogXCJcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICAgIHRoaXMudmlzaXQobm9kZS5tZW1iZXJzKTtcbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5zYi5qb2luKFwiXFxuXCIpKTtcbiAgICAgIGxldCBuZXdTdGF0ZW1lbnRzID0gdGhpcy5zYi5tYXAocGFyc2VUb3BMZXZlbFN0YXRlbWVudHMpLmZsYXQoKS5tYXAoKHMpID0+IFJhbmdlVHJhbnNmb3JtLnZpc2l0KHMsIG5vZGUpKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKG5ld1N0YXRlbWVudHMubWFwKHRvU3RyaW5nKSlcbiAgICAgIGxldCBzdGF0ZW1lbnRzID0gbmV3U3RhdGVtZW50cy5tYXAoKG4pID0+IHtcbiAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBGdW5jdGlvbkRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgICAgICAgbi5mbGFncyA9IG4uZmxhZ3MgfCBDb21tb25GbGFncy5NT0RVTEVfRVhQT1JUO1xuICAgICAgICB9XG4gICAgICAgIG4ucmFuZ2UgPSBub2RlLnJhbmdlO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pO1xuICAgICAgbm9kZS5yYW5nZS5zb3VyY2Uuc3RhdGVtZW50cy5wdXNoKC4uLnN0YXRlbWVudHMpO1xuICAgICAgLy8gY29uc29sZS5sb2codG9TdHJpbmcobm9kZS5yYW5nZS5zb3VyY2UpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIm5lYXJCaW5kZ2VuXCI7XG4gIH1cblxuICB2aXNpdFNvdXJjZShub2RlOiBTb3VyY2UpOiB2b2lkIHtcbiAgICBpZiAobm9kZS5zb3VyY2VLaW5kICE9IFNvdXJjZUtpbmQuVVNFUl9FTlRSWSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhub2RlLmludGVybmFsUGF0aClcbiAgICBzdXBlci52aXNpdFNvdXJjZShub2RlKTtcbiAgfVxuXG4gIHN0YXRpYyB2aXNpdChzb3VyY2VzOiBTb3VyY2VbXSk6IFNvdXJjZVtdIHtcbiAgICBsZXQgdmlzaXRvciA9IG5ldyBDbGFzc0V4cG9ydGVyKCk7XG4gICAgdmlzaXRvci52aXNpdChzb3VyY2VzKTtcbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxufVxuIl19