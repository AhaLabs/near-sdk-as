"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassExporter = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const transformRange_1 = require("visitor-as/dist/transformRange");
const common_1 = require("./common");
const utils_1 = require("./utils");
class ClassExporter extends visitor_as_1.ClassDecorator {
    sb = [];
    static classSeen;
    static hasConstructor;
    static get className() {
        return utils_1.toString(ClassExporter.classSeen.name);
    }
    checkMethods(name) {
        let _class = ClassExporter.classSeen;
        _class.members.forEach((member) => {
            if (member instanceof as_1.MethodDeclaration &&
                !member.is(as_1.CommonFlags.PRIVATE)) {
                if (utils_1.toString(member.name) === name) {
                    throw new Error(`Method "${utils_1.toString(member.name)}" already used; cannot export constructor using the same name.`);
                }
            }
        });
    }
    visitFieldDeclaration(node) { }
    visitMethodDeclaration(node) {
        if (node.is(as_1.CommonFlags.SET) || node.is(as_1.CommonFlags.GET)) {
            throw new Error("Exported Singleton class cannot have properties. Found " +
                node.name.text);
        }
        // Private methods should be skipped.
        if (node.is(as_1.CommonFlags.PRIVATE)) {
            return;
        }
        let privateCheck = visitor_as_1.utils.hasDecorator(node, common_1.PRIVATE_DECORATOR)
            ? `__assertPrivate();`
            : "";
        let name = utils_1.toString(node.name);
        let decorators = (node.decorators || []).map(utils_1.toString);
        let returnType = utils_1.toString(node.signature.returnType);
        let origParams = node.signature.parameters.map(visitor_as_1.utils.cloneNode);
        let parameters = origParams.map((param) => {
            if (param.implicitFieldDeclaration) {
                param.name.text = param.name.text.substring(2);
            }
            return utils_1.toString(param);
        });
        let pramNames = origParams.map((param) => {
            return utils_1.toString(param.name);
        });
        let isInit = name === "constructor";
        let assertStr = "";
        if (isInit) {
            assertStr = `assert(isNull(__contract), "contract is already initialized");`;
        }
        else if (ClassExporter.hasConstructor) {
            assertStr = `assert(!isNull(__contract), "contract is not initialized");`;
        }
        let isVoid = returnType === "void";
        let body = isInit
            ? `__contract = new ${ClassExporter.className}(${pramNames.join(", ")});`
            : `${!isVoid ? "let res =  " : ""}__contract.${name}(${pramNames.join(", ")});`;
        if (isInit) {
            name = "init";
            parameters = origParams.map((node) => `${utils_1.toString(node.name)}: ${utils_1.toString(node.type)}${node.initializer ? " = " + utils_1.toString(node.initializer) : ""}`);
            returnType = "void";
        }
        if (isInit) {
            if (!decorators.some((decorator) => decorator.includes("exportAs"))) {
                decorators.push(`@exportAs("new")`);
                this.checkMethods("new");
            }
            else {
                let decorator = node.decorators.find((d) => utils_1.toString(d.name) === "exportAs");
                if (decorator.args.length == 1) {
                    this.checkMethods(utils_1.toString(decorator.args[0]));
                }
            }
        }
        const hasMutateState = decorators.some((decorator) => {
            let res = decorator.includes("mutateState");
            return res;
        });
        this.sb.push(`${decorators.join("\n")}
export function ${name}(${parameters.join(", ")}): ${returnType} {
  ${privateCheck}
  ${assertStr}
  ${body}
  ${isInit || hasMutateState ? `__setState(__contract);` : ""}
  ${isVoid || isInit ? "" : "return res;"}
}`);
    }
    visitClassDeclaration(node) {
        if (node.is(as_1.CommonFlags.EXPORT)) {
            let name = utils_1.toString(node.name);
            if (ClassExporter.classSeen) {
                throw new Error(`Cannot export class ${name}. ${ClassExporter.className} already exported. `);
            }
            ClassExporter.classSeen = node;
            ClassExporter.hasConstructor = node.members.some((member) => {
                if (member instanceof as_1.MethodDeclaration) {
                    return utils_1.toString(member.name) === "constructor";
                }
                return false;
            });
            this.sb.push(`let __contract: ${name};`);
            this.sb.push(`if (__checkState()) {
  __contract = __getState<${name}>();
}${!ClassExporter.hasConstructor
                ? ` else {
  __contract = new ${name}();
}`
                : ""}`);
            this.visit(node.members);
            node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
            let newStatements = this.sb
                .map(common_1.parseTopLevelStatements)
                .flat()
                .map((s) => transformRange_1.RangeTransform.visit(s, node));
            let statements = newStatements.map((n) => {
                if (n instanceof as_1.FunctionDeclaration) {
                    n.flags = n.flags | as_1.CommonFlags.EXPORT;
                    n.flags = n.flags | as_1.CommonFlags.MODULE_EXPORT;
                }
                n.range = node.range;
                return n;
            });
            node.range.source.statements.push(...statements);
        }
    }
    get name() {
        return "nearBindgen";
    }
    visitSource(node) {
        if (node.sourceKind != as_1.SourceKind.USER_ENTRY) {
            return;
        }
        super.visitSource(node);
    }
    static visit(sources) {
        let visitor = new ClassExporter();
        visitor.visit(sources);
        return sources;
    }
}
exports.ClassExporter = ClassExporter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xhc3NFeHBvcnRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9jbGFzc0V4cG9ydGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHNDQVN1QjtBQUN2QiwyQ0FBbUQ7QUFDbkQsbUVBQWdFO0FBQ2hFLHFDQUErRTtBQUMvRSxtQ0FBbUM7QUFFbkMsTUFBYSxhQUFjLFNBQVEsMkJBQWM7SUFDL0MsRUFBRSxHQUFhLEVBQUUsQ0FBQztJQUNsQixNQUFNLENBQUMsU0FBUyxDQUFtQjtJQUNuQyxNQUFNLENBQUMsY0FBYyxDQUFVO0lBRS9CLE1BQU0sS0FBSyxTQUFTO1FBQ2xCLE9BQU8sZ0JBQVEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRCxZQUFZLENBQUMsSUFBWTtRQUN2QixJQUFJLE1BQU0sR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDaEMsSUFDRSxNQUFNLFlBQVksc0JBQWlCO2dCQUNuQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxPQUFPLENBQUMsRUFDL0I7Z0JBQ0EsSUFBSSxnQkFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxJQUFJLEVBQUU7b0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQ2IsV0FBVyxnQkFBUSxDQUNqQixNQUFNLENBQUMsSUFBSSxDQUNaLGdFQUFnRSxDQUNsRSxDQUFDO2lCQUNIO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxxQkFBcUIsQ0FBQyxJQUFzQixJQUFTLENBQUM7SUFFdEQsc0JBQXNCLENBQUMsSUFBdUI7UUFDNUMsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFXLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFB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cG9ydCB7XG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIEZpZWxkRGVjbGFyYXRpb24sXG4gIE1ldGhvZERlY2xhcmF0aW9uLFxuICBTb3VyY2UsXG4gIENvbW1vbkZsYWdzLFxuICBTb3VyY2VLaW5kLFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBCbG9ja1N0YXRlbWVudCxcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IHV0aWxzLCBDbGFzc0RlY29yYXRvciB9IGZyb20gXCJ2aXNpdG9yLWFzXCI7XG5pbXBvcnQgeyBSYW5nZVRyYW5zZm9ybSB9IGZyb20gXCJ2aXNpdG9yLWFzL2Rpc3QvdHJhbnNmb3JtUmFuZ2VcIjtcbmltcG9ydCB7IGlzRW50cnksIHBhcnNlVG9wTGV2ZWxTdGF0ZW1lbnRzLCBQUklWQVRFX0RFQ09SQVRPUiB9IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgdG9TdHJpbmcgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgY2xhc3MgQ2xhc3NFeHBvcnRlciBleHRlbmRzIENsYXNzRGVjb3JhdG9yIHtcbiAgc2I6IHN0cmluZ1tdID0gW107XG4gIHN0YXRpYyBjbGFzc1NlZW46IENsYXNzRGVjbGFyYXRpb247XG4gIHN0YXRpYyBoYXNDb25zdHJ1Y3RvcjogYm9vbGVhbjtcblxuICBzdGF0aWMgZ2V0IGNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N0cmluZyhDbGFzc0V4cG9ydGVyLmNsYXNzU2Vlbi5uYW1lKTtcbiAgfVxuXG4gIGNoZWNrTWV0aG9kcyhuYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgX2NsYXNzID0gQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW47XG4gICAgX2NsYXNzLm1lbWJlcnMuZm9yRWFjaCgobWVtYmVyKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIG1lbWJlciBpbnN0YW5jZW9mIE1ldGhvZERlY2xhcmF0aW9uICYmXG4gICAgICAgICFtZW1iZXIuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSlcbiAgICAgICkge1xuICAgICAgICBpZiAodG9TdHJpbmcobWVtYmVyLm5hbWUpID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE1ldGhvZCBcIiR7dG9TdHJpbmcoXG4gICAgICAgICAgICAgIG1lbWJlci5uYW1lXG4gICAgICAgICAgICApfVwiIGFscmVhZHkgdXNlZDsgY2Fubm90IGV4cG9ydCBjb25zdHJ1Y3RvciB1c2luZyB0aGUgc2FtZSBuYW1lLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2aXNpdEZpZWxkRGVjbGFyYXRpb24obm9kZTogRmllbGREZWNsYXJhdGlvbik6IHZvaWQge31cblxuICB2aXNpdE1ldGhvZERlY2xhcmF0aW9uKG5vZGU6IE1ldGhvZERlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuU0VUKSB8fCBub2RlLmlzKENvbW1vbkZsYWdzLkdFVCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJFeHBvcnRlZCBTaW5nbGV0b24gY2xhc3MgY2Fubm90IGhhdmUgcHJvcGVydGllcy4gRm91bmQgXCIgK1xuICAgICAgICAgIG5vZGUubmFtZS50ZXh0XG4gICAgICApO1xuICAgIH1cbiAgICAvLyBQcml2YXRlIG1ldGhvZHMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgaWYgKG5vZGUuaXMoQ29tbW9uRmxhZ3MuUFJJVkFURSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByaXZhdGVDaGVjayA9IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBQUklWQVRFX0RFQ09SQVRPUilcbiAgICAgID8gYF9fYXNzZXJ0UHJpdmF0ZSgpO2BcbiAgICAgIDogXCJcIjtcbiAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgbGV0IGRlY29yYXRvcnMgPSAobm9kZS5kZWNvcmF0b3JzIHx8IFtdKS5tYXAodG9TdHJpbmcpO1xuICAgIGxldCByZXR1cm5UeXBlID0gdG9TdHJpbmcobm9kZS5zaWduYXR1cmUucmV0dXJuVHlwZSk7XG4gICAgbGV0IG9yaWdQYXJhbXMgPSBub2RlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzLm1hcCh1dGlscy5jbG9uZU5vZGUpO1xuICAgIGxldCBwYXJhbWV0ZXJzID0gb3JpZ1BhcmFtcy5tYXAoKHBhcmFtKSA9PiB7XG4gICAgICBpZiAocGFyYW0uaW1wbGljaXRGaWVsZERlY2xhcmF0aW9uKSB7XG4gICAgICAgIHBhcmFtLm5hbWUudGV4dCA9IHBhcmFtLm5hbWUudGV4dC5zdWJzdHJpbmcoMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9TdHJpbmcocGFyYW0pO1xuICAgIH0pO1xuICAgIGxldCBwcmFtTmFtZXMgPSBvcmlnUGFyYW1zLm1hcCgocGFyYW0pID0+IHtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwYXJhbS5uYW1lKTtcbiAgICB9KTtcbiAgICBsZXQgaXNJbml0ID0gbmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIGxldCBhc3NlcnRTdHI6IHN0cmluZyA9IFwiXCI7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydChpc051bGwoX19jb250cmFjdCksIFwiY29udHJhY3QgaXMgYWxyZWFkeSBpbml0aWFsaXplZFwiKTtgO1xuICAgIH0gZWxzZSBpZiAoQ2xhc3NFeHBvcnRlci5oYXNDb25zdHJ1Y3Rvcikge1xuICAgICAgYXNzZXJ0U3RyID0gYGFzc2VydCghaXNOdWxsKF9fY29udHJhY3QpLCBcImNvbnRyYWN0IGlzIG5vdCBpbml0aWFsaXplZFwiKTtgO1xuICAgIH1cbiAgICBsZXQgaXNWb2lkID0gcmV0dXJuVHlwZSA9PT0gXCJ2b2lkXCI7XG4gICAgbGV0IGJvZHkgPSBpc0luaXRcbiAgICAgID8gYF9fY29udHJhY3QgPSBuZXcgJHtDbGFzc0V4cG9ydGVyLmNsYXNzTmFtZX0oJHtwcmFtTmFtZXMuam9pbihcIiwgXCIpfSk7YFxuICAgICAgOiBgJHshaXNWb2lkID8gXCJsZXQgcmVzID0gIFwiIDogXCJcIn1fX2NvbnRyYWN0LiR7bmFtZX0oJHtwcmFtTmFtZXMuam9pbihcbiAgICAgICAgICBcIiwgXCJcbiAgICAgICAgKX0pO2A7XG4gICAgaWYgKGlzSW5pdCkge1xuICAgICAgbmFtZSA9IFwiaW5pdFwiO1xuICAgICAgcGFyYW1ldGVycyA9IG9yaWdQYXJhbXMubWFwKFxuICAgICAgICAobm9kZSkgPT5cbiAgICAgICAgICBgJHt0b1N0cmluZyhub2RlLm5hbWUpfTogJHt0b1N0cmluZyhub2RlLnR5cGUpfSR7XG4gICAgICAgICAgICBub2RlLmluaXRpYWxpemVyID8gXCIgPSBcIiArIHRvU3RyaW5nKG5vZGUuaW5pdGlhbGl6ZXIpIDogXCJcIlxuICAgICAgICAgIH1gXG4gICAgICApO1xuICAgICAgcmV0dXJuVHlwZSA9IFwidm9pZFwiO1xuICAgIH1cbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICBpZiAoIWRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiBkZWNvcmF0b3IuaW5jbHVkZXMoXCJleHBvcnRBc1wiKSkpIHtcbiAgICAgICAgZGVjb3JhdG9ycy5wdXNoKGBAZXhwb3J0QXMoXCJuZXdcIilgKTtcbiAgICAgICAgdGhpcy5jaGVja01ldGhvZHMoXCJuZXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGVjb3JhdG9yID0gbm9kZS5kZWNvcmF0b3JzIS5maW5kKFxuICAgICAgICAgIChkKSA9PiB0b1N0cmluZyhkLm5hbWUpID09PSBcImV4cG9ydEFzXCJcbiAgICAgICAgKSE7XG4gICAgICAgIGlmIChkZWNvcmF0b3IuYXJncyEubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTWV0aG9kcyh0b1N0cmluZyhkZWNvcmF0b3IuYXJncyFbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYXNNdXRhdGVTdGF0ZSA9IGRlY29yYXRvcnMuc29tZSgoZGVjb3JhdG9yKSA9PiB7XG4gICAgICBsZXQgcmVzID0gZGVjb3JhdG9yLmluY2x1ZGVzKFwibXV0YXRlU3RhdGVcIik7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHRoaXMuc2IucHVzaChcbiAgICAgIGAke2RlY29yYXRvcnMuam9pbihcIlxcblwiKX1cbmV4cG9ydCBmdW5jdGlvbiAke25hbWV9KCR7cGFyYW1ldGVycy5qb2luKFwiLCBcIil9KTogJHtyZXR1cm5UeXBlfSB7XG4gICR7cHJpdmF0ZUNoZWNrfVxuICAke2Fzc2VydFN0cn1cbiAgJHtib2R5fVxuICAke2lzSW5pdCB8fCBoYXNNdXRhdGVTdGF0ZSA/IGBfX3NldFN0YXRlKF9fY29udHJhY3QpO2AgOiBcIlwifVxuICAke2lzVm9pZCB8fCBpc0luaXQgPyBcIlwiIDogXCJyZXR1cm4gcmVzO1wifVxufWBcbiAgICApO1xuICB9XG5cbiAgdmlzaXRDbGFzc0RlY2xhcmF0aW9uKG5vZGU6IENsYXNzRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBpZiAobm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpKSB7XG4gICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgICBpZiAoQ2xhc3NFeHBvcnRlci5jbGFzc1NlZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZXhwb3J0IGNsYXNzICR7bmFtZX0uICR7Q2xhc3NFeHBvcnRlci5jbGFzc05hbWV9IGFscmVhZHkgZXhwb3J0ZWQuIGBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIENsYXNzRXhwb3J0ZXIuY2xhc3NTZWVuID0gbm9kZTtcbiAgICAgIENsYXNzRXhwb3J0ZXIuaGFzQ29uc3RydWN0b3IgPSBub2RlLm1lbWJlcnMuc29tZSgobWVtYmVyKSA9PiB7XG4gICAgICAgIGlmIChtZW1iZXIgaW5zdGFuY2VvZiBNZXRob2REZWNsYXJhdGlvbikge1xuICAgICAgICAgIHJldHVybiB0b1N0cmluZyhtZW1iZXIubmFtZSkgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2IucHVzaChgbGV0IF9fY29udHJhY3Q6ICR7bmFtZX07YCk7XG4gICAgICB0aGlzLnNiLnB1c2goXG4gICAgICAgIGBpZiAoX19jaGVja1N0YXRlKCkpIHtcbiAgX19jb250cmFjdCA9IF9fZ2V0U3RhdGU8JHtuYW1lfT4oKTtcbn0ke1xuICAgICAgICAgICFDbGFzc0V4cG9ydGVyLmhhc0NvbnN0cnVjdG9yXG4gICAgICAgICAgICA/IGAgZWxzZSB7XG4gIF9fY29udHJhY3QgPSBuZXcgJHtuYW1lfSgpO1xufWBcbiAgICAgICAgICAgIDogXCJcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICAgIHRoaXMudmlzaXQobm9kZS5tZW1iZXJzKTtcbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgICAgbGV0IG5ld1N0YXRlbWVudHMgPSB0aGlzLnNiXG4gICAgICAgIC5tYXAocGFyc2VUb3BMZXZlbFN0YXRlbWVudHMpXG4gICAgICAgIC5mbGF0KClcbiAgICAgICAgLm1hcCgocykgPT4gUmFuZ2VUcmFuc2Zvcm0udmlzaXQocywgbm9kZSkpO1xuICAgICAgbGV0IHN0YXRlbWVudHMgPSBuZXdTdGF0ZW1lbnRzLm1hcCgobikgPT4ge1xuICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBuLmZsYWdzID0gbi5mbGFncyB8IENvbW1vbkZsYWdzLkVYUE9SVDtcbiAgICAgICAgICBuLmZsYWdzID0gbi5mbGFncyB8IENvbW1vbkZsYWdzLk1PRFVMRV9FWFBPUlQ7XG4gICAgICAgIH1cbiAgICAgICAgbi5yYW5nZSA9IG5vZGUucmFuZ2U7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSk7XG4gICAgICBub2RlLnJhbmdlLnNvdXJjZS5zdGF0ZW1lbnRzLnB1c2goLi4uc3RhdGVtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJuZWFyQmluZGdlblwiO1xuICB9XG5cbiAgdmlzaXRTb3VyY2Uobm9kZTogU291cmNlKTogdm9pZCB7XG4gICAgaWYgKG5vZGUuc291cmNlS2luZCAhPSBTb3VyY2VLaW5kLlVTRVJfRU5UUlkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIudmlzaXRTb3VyY2Uobm9kZSk7XG4gIH1cblxuICBzdGF0aWMgdmlzaXQoc291cmNlczogU291cmNlW10pOiBTb3VyY2VbXSB7XG4gICAgbGV0IHZpc2l0b3IgPSBuZXcgQ2xhc3NFeHBvcnRlcigpO1xuICAgIHZpc2l0b3IudmlzaXQoc291cmNlcyk7XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn1cbiJdfQ==