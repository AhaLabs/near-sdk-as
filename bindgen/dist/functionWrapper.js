"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionExportWrapper = exports.FunctionClass = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const common_1 = require("./common");
const utils_1 = require("./utils");
const transformRange_1 = require("visitor-as/dist/transformRange");
class FunctionClass extends visitor_as_1.BaseVisitor {
    _class;
    visitFunctionDeclaration(node) {
        let name = utils_1.getName(node);
        let fields = node.signature.parameters.map((p) => `${utils_1.toString(p.name)}: ${utils_1.getName(p.type)}`);
        let params = node.signature.parameters.map((p) => `this.${utils_1.getName(p)}`);
        if (fields.length > 0) {
            // add blank to make join add ;
            fields.push("");
        }
        const fieldStrs = fields.join(";\n");
        let _classStr = `class ${name}__class {
  ${fieldStrs}
  call(): ${utils_1.getName(node.signature.returnType)} {
    ${common_1.returnsVoid(node) ? "" : "return "}${name}(${params.join(",")});
  }
}`;
        let _class = (visitor_as_1.SimpleParser.parseTopLevelStatement(_classStr));
        // MethodInjector.visit(_class);
        this._class = _class;
    }
    static visit(node) {
        const funcClass = new FunctionClass();
        funcClass.visit(node);
        return funcClass._class;
    }
}
exports.FunctionClass = FunctionClass;
function emptySignature(node) {
    return common_1.numOfParameters(node) == 0 && common_1.returnsVoid(node);
}
class FunctionExportWrapper extends visitor_as_1.BaseVisitor {
    static isTest = false;
    functions = [];
    exports = [];
    wrappedFuncs = new Set();
    classWrappers = [];
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes(".spec."));
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has(utils_1.toString(node.name));
        let noInputOrOutput = emptySignature(node);
        if (!isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            FunctionExportWrapper.isTest)
            return false;
        return common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        const name = utils_1.toString(node.name);
        if (!this.needsWrapper(node)) {
            if ((common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR)) &&
                !this.wrappedFuncs.has(name) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                const snakeCase = this.camelCaseToSnakeCaseExport(name, "");
                this.wrappedFuncs.add(name);
                if (snakeCase) {
                    this.exports.push(snakeCase);
                }
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        if (common_1.numOfParameters(node) > 0) {
            const _class = FunctionClass.visit(node);
            transformRange_1.RangeTransform.visit(_class, node);
            this.classWrappers.push(_class);
        }
        this.functions.push(common_1.parseTopLevelStatements(this.generateWrapperFunction(node))[0]);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(name);
    }
    camelCaseToSnakeCaseExport(name, prefix = common_1.WRAPPER_PREFIX) {
        let s = utils_1.makeSnakeCase(name);
        if (s.normalize() === name.normalize()) {
            return "";
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let funcSource = [];
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = utils_1.toString(returnType);
        let name = utils_1.getName(func);
        if (func.decorators && func.decorators.length > 0) {
            funcSource.push(func.decorators.map((decorator) => utils_1.toString(decorator)).join("\n"));
        }
        const className = name + "__class";
        funcSource.push(`
    function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            funcSource.push(`  const _class = JSON.parse<${className}>(getInputString())`);
        }
        if (returnTypeName !== "void") {
            if (params.length > 0) {
                funcSource.push(`let result: ${returnTypeName} = _class.call();`);
            }
            else {
                funcSource.push(`let result: ${returnTypeName} = ${name}();`);
            }
            funcSource.push(`
      const val = String.UTF8.encode(JSON.stringify(result));
      value_return(val.byteLength, changetype<usize>(val));
  `);
        }
        else {
            if (params.length > 0) {
                funcSource.push(`_class.call()`);
            }
            else {
                funcSource.push(`${name}();`);
            }
        }
        funcSource.push(`}`);
        this.addExport(name);
        return funcSource.join("\n");
    }
    addExport(name) {
        this.exports.push(`export {${common_1.WRAPPER_PREFIX + name} as ${name}}`);
        let res = this.camelCaseToSnakeCaseExport(name, common_1.WRAPPER_PREFIX);
        if (res) {
            this.exports.push(res);
        }
    }
    visitSource(node) {
        super.visitSource(node);
        const newParser = new as_1.Parser();
        const lastStatement = (node.statements.length && node.statements[node.statements.length - 1]) ||
            node;
        if (this.functions.length > 0) {
            node.statements.push(...this.functions.map((n) => transformRange_1.RangeTransform.visit(n, lastStatement)));
            const str = this.exports.join("\n");
            newParser.parseFile(str, node.normalizedPath, common_1.isEntry(node));
            const exportsSource = newParser.sources[0];
            node.statements = node.statements.concat(exportsSource.statements);
            node.statements.push(...this.classWrappers);
        }
    }
    static visit(sources) {
        FunctionExportWrapper.checkTestBuild(sources);
        sources.forEach((s) => {
            new FunctionExportWrapper().visit(s);
        });
    }
}
exports.FunctionExportWrapper = FunctionExportWrapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25XcmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Z1bmN0aW9uV3JhcHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxzQ0FTdUI7QUFDdkIsMkNBQThEO0FBQzlELHFDQVFrQjtBQUNsQixtQ0FBMkQ7QUFDM0QsbUVBQWdFO0FBRWhFLE1BQWEsYUFBYyxTQUFRLHdCQUFXO0lBQzVDLE1BQU0sQ0FBbUI7SUFFekIsd0JBQXdCLENBQUMsSUFBeUI7UUFDaEQsSUFBSSxJQUFJLEdBQUcsZUFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FDeEMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsZ0JBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssZUFBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNqRCxDQUFDO1FBQ0YsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxRQUFRLGVBQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDeEUsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyQiwrQkFBK0I7WUFDL0IsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNqQjtRQUVELE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsSUFBSSxTQUFTLEdBQUcsU0FBUyxJQUFJO0lBQzdCLFNBQVM7WUFDRCxlQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7TUFDeEMsb0JBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMs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QUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxjQUFjLEVBQUUsZ0JBQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQzdELE1BQU0sYUFBYSxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0MsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDN0M7SUFDSCxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFpQjtRQUM1QixxQkFBcUIsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1lBQ3BCLElBQUkscUJBQXFCLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOztBQS9JSCxzREFnSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBTb3VyY2UsXG4gIENvbW1vbkZsYWdzLFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBTdGF0ZW1lbnQsXG4gIFByb2dyYW0sXG4gIE5vZGVLaW5kLFxuICBQYXJzZXIsXG59IGZyb20gXCJ2aXNpdG9yLWFzL2FzXCI7XG5pbXBvcnQgeyB1dGlscywgQmFzZVZpc2l0b3IsIFNpbXBsZVBhcnNlciB9IGZyb20gXCJ2aXNpdG9yLWFzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQsXG4gIGlzRW50cnksXG4gIE5FQVJfREVDT1JBVE9SLFxuICBudW1PZlBhcmFtZXRlcnMsXG4gIHBhcnNlVG9wTGV2ZWxTdGF0ZW1lbnRzLFxuICByZXR1cm5zVm9pZCxcbiAgV1JBUFBFUl9QUkVGSVgsXG59IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0IHsgZ2V0TmFtZSwgbWFrZVNuYWtlQ2FzZSwgdG9TdHJpbmcgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgUmFuZ2VUcmFuc2Zvcm0gfSBmcm9tIFwidmlzaXRvci1hcy9kaXN0L3RyYW5zZm9ybVJhbmdlXCI7XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkNsYXNzIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xuICBfY2xhc3M6IENsYXNzRGVjbGFyYXRpb247XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBsZXQgbmFtZSA9IGdldE5hbWUobm9kZSk7XG4gICAgbGV0IGZpZWxkcyA9IG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubWFwKFxuICAgICAgKHApID0+IGAke3RvU3RyaW5nKHAubmFtZSl9OiAke2dldE5hbWUocC50eXBlKX1gXG4gICAgKTtcbiAgICBsZXQgcGFyYW1zID0gbm9kZS5zaWduYXR1cmUucGFyYW1ldGVycy5tYXAoKHApID0+IGB0aGlzLiR7Z2V0TmFtZShwKX1gKTtcbiAgICBpZiAoZmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIGFkZCBibGFuayB0byBtYWtlIGpvaW4gYWRkIDtcbiAgICAgIGZpZWxkcy5wdXNoKFwiXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkU3RycyA9IGZpZWxkcy5qb2luKFwiO1xcblwiKTtcbiAgICBsZXQgX2NsYXNzU3RyID0gYGNsYXNzICR7bmFtZX1fX2NsYXNzIHtcbiAgJHtmaWVsZFN0cnN9XG4gIGNhbGwoKTogJHtnZXROYW1lKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpfSB7XG4gICAgJHtyZXR1cm5zVm9pZChub2RlKSA/IFwiXCIgOiBcInJldHVybiBcIn0ke25hbWV9KCR7cGFyYW1zLmpvaW4oXCIsXCIpfSk7XG4gIH1cbn1gO1xuICAgIGxldCBfY2xhc3MgPSA8Q2xhc3NEZWNsYXJhdGlvbj4oXG4gICAgICBTaW1wbGVQYXJzZXIucGFyc2VUb3BMZXZlbFN0YXRlbWVudChfY2xhc3NTdHIpXG4gICAgKTtcbiAgICAvLyBNZXRob2RJbmplY3Rvci52aXNpdChfY2xhc3MpO1xuICAgIHRoaXMuX2NsYXNzID0gX2NsYXNzO1xuICB9XG5cbiAgc3RhdGljIHZpc2l0KG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBDbGFzc0RlY2xhcmF0aW9uIHtcbiAgICBjb25zdCBmdW5jQ2xhc3MgPSBuZXcgRnVuY3Rpb25DbGFzcygpO1xuICAgIGZ1bmNDbGFzcy52aXNpdChub2RlKTtcbiAgICByZXR1cm4gZnVuY0NsYXNzLl9jbGFzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVNpZ25hdHVyZShub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBudW1PZlBhcmFtZXRlcnMobm9kZSkgPT0gMCAmJiByZXR1cm5zVm9pZChub2RlKTtcbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkV4cG9ydFdyYXBwZXIgZXh0ZW5kcyBCYXNlVmlzaXRvciB7XG4gIHN0YXRpYyBpc1Rlc3Q6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZnVuY3Rpb25zOiBTdGF0ZW1lbnRbXSA9IFtdO1xuICBleHBvcnRzOiBzdHJpbmdbXSA9IFtdO1xuICB3cmFwcGVkRnVuY3M6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuICBjbGFzc1dyYXBwZXJzOiBDbGFzc0RlY2xhcmF0aW9uW10gPSBbXTtcblxuICBzdGF0aWMgY2hlY2tUZXN0QnVpbGQoc291cmNlczogU291cmNlW10pIHtcbiAgICB0aGlzLmlzVGVzdCA9IHNvdXJjZXMuc29tZSgocykgPT4gcy5ub3JtYWxpemVkUGF0aC5pbmNsdWRlcyhcIi5zcGVjLlwiKSk7XG4gIH1cblxuICBuZWVkc1dyYXBwZXIobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICAgIGxldCBpc0V4cG9ydCA9IG5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKTtcbiAgICBsZXQgYWxyZWFkeVdyYXBwZWQgPSB0aGlzLndyYXBwZWRGdW5jcy5oYXModG9TdHJpbmcobm9kZS5uYW1lKSk7XG4gICAgbGV0IG5vSW5wdXRPck91dHB1dCA9IGVtcHR5U2lnbmF0dXJlKG5vZGUpO1xuICAgIGlmIChcbiAgICAgICFpc0V4cG9ydCB8fFxuICAgICAgYWxyZWFkeVdyYXBwZWQgfHxcbiAgICAgIG5vSW5wdXRPck91dHB1dCB8fFxuICAgICAgRnVuY3Rpb25FeHBvcnRXcmFwcGVyLmlzVGVzdFxuICAgIClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaXNFbnRyeShub2RlKSB8fCB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgTkVBUl9ERUNPUkFUT1IpO1xuICB9XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBuYW1lID0gdG9TdHJpbmcobm9kZS5uYW1lKTtcbiAgICBpZiAoIXRoaXMubmVlZHNXcmFwcGVyKG5vZGUpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIChpc0VudHJ5KG5vZGUpIHx8IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBORUFSX0RFQ09SQVRPUikpICYmXG4gICAgICAgICF0aGlzLndyYXBwZWRGdW5jcy5oYXMobmFtZSkgJiZcbiAgICAgICAgbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc25ha2VDYXNlID0gdGhpcy5jYW1lbENhc2VUb1NuYWtlQ2FzZUV4cG9ydChuYW1lLCBcIlwiKTtcbiAgICAgICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKG5hbWUpO1xuICAgICAgICBpZiAoc25ha2VDYXNlKSB7XG4gICAgICAgICAgdGhpcy5leHBvcnRzLnB1c2goc25ha2VDYXNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3VwZXIudmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID4gMCkge1xuICAgICAgY29uc3QgX2NsYXNzID0gRnVuY3Rpb25DbGFzcy52aXNpdChub2RlKTtcbiAgICAgIFJhbmdlVHJhbnNmb3JtLnZpc2l0KF9jbGFzcywgbm9kZSk7XG4gICAgICB0aGlzLmNsYXNzV3JhcHBlcnMucHVzaChfY2xhc3MpO1xuICAgIH1cbiAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKFxuICAgICAgcGFyc2VUb3BMZXZlbFN0YXRlbWVudHModGhpcy5nZW5lcmF0ZVdyYXBwZXJGdW5jdGlvbihub2RlKSlbMF1cbiAgICApO1xuICAgIC8vIENoYW5nZSBmdW5jdGlvbiB0byBub3QgYmUgYW4gZXhwb3J0XG4gICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgXiBDb21tb25GbGFncy5FWFBPUlQ7XG4gICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKG5hbWUpO1xuICB9XG5cbiAgY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHByZWZpeDogc3RyaW5nID0gV1JBUFBFUl9QUkVGSVhcbiAgKTogc3RyaW5nIHtcbiAgICBsZXQgcyA9IG1ha2VTbmFrZUNhc2UobmFtZSk7XG4gICAgaWYgKHMubm9ybWFsaXplKCkgPT09IG5hbWUubm9ybWFsaXplKCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYGV4cG9ydCB7ICR7cHJlZml4ICsgbmFtZX0gYXMgJHtzfSB9YDtcbiAgfVxuXG4gIC8qXG4gIENyZWF0ZSBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4cG9ydCBpbiB0aGUgZnVuY3Rpb24ncyBwbGFjZS5cbiAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVdyYXBwZXJGdW5jdGlvbihmdW5jOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogc3RyaW5nIHtcbiAgICBsZXQgZnVuY1NvdXJjZTogc3RyaW5nW10gPSBbXTtcbiAgICBsZXQgc2lnbmF0dXJlID0gZnVuYy5zaWduYXR1cmU7XG4gICAgbGV0IHBhcmFtcyA9IHNpZ25hdHVyZS5wYXJhbWV0ZXJzO1xuICAgIGxldCByZXR1cm5UeXBlID0gc2lnbmF0dXJlLnJldHVyblR5cGU7XG4gICAgbGV0IHJldHVyblR5cGVOYW1lID0gdG9TdHJpbmcocmV0dXJuVHlwZSk7XG4gICAgbGV0IG5hbWUgPSBnZXROYW1lKGZ1bmMpO1xuICAgIGlmIChmdW5jLmRlY29yYXRvcnMgJiYgZnVuYy5kZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZ1bmNTb3VyY2UucHVzaChcbiAgICAgICAgZnVuYy5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiB0b1N0cmluZyhkZWNvcmF0b3IpKS5qb2luKFwiXFxuXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc05hbWUgPSBuYW1lICsgXCJfX2NsYXNzXCI7XG4gICAgZnVuY1NvdXJjZS5wdXNoKGBcbiAgICBmdW5jdGlvbiBfX3dyYXBwZXJfJHtuYW1lfSgpOiB2b2lkIHtgKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZ1bmNTb3VyY2UucHVzaChcbiAgICAgICAgYCAgY29uc3QgX2NsYXNzID0gSlNPTi5wYXJzZTwke2NsYXNzTmFtZX0+KGdldElucHV0U3RyaW5nKCkpYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHJldHVyblR5cGVOYW1lICE9PSBcInZvaWRcIikge1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZ1bmNTb3VyY2UucHVzaChgbGV0IHJlc3VsdDogJHtyZXR1cm5UeXBlTmFtZX0gPSBfY2xhc3MuY2FsbCgpO2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY1NvdXJjZS5wdXNoKGBsZXQgcmVzdWx0OiAke3JldHVyblR5cGVOYW1lfSA9ICR7bmFtZX0oKTtgKTtcbiAgICAgIH1cbiAgICAgIGZ1bmNTb3VyY2UucHVzaChgXG4gICAgICBjb25zdCB2YWwgPSBTdHJpbmcuVVRGOC5lbmNvZGUoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICB2YWx1ZV9yZXR1cm4odmFsLmJ5dGVMZW5ndGgsIGNoYW5nZXR5cGU8dXNpemU+KHZhbCkpO1xuICBgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZ1bmNTb3VyY2UucHVzaChgX2NsYXNzLmNhbGwoKWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY1NvdXJjZS5wdXNoKGAke25hbWV9KCk7YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmNTb3VyY2UucHVzaChgfWApO1xuICAgIHRoaXMuYWRkRXhwb3J0KG5hbWUpO1xuICAgIHJldHVybiBmdW5jU291cmNlLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBhZGRFeHBvcnQobmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5leHBvcnRzLnB1c2goYGV4cG9ydCB7JHtXUkFQUEVSX1BSRUZJWCArIG5hbWV9IGFzICR7bmFtZX19YCk7XG4gICAgbGV0IHJlcyA9IHRoaXMuY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQobmFtZSwgV1JBUFBFUl9QUkVGSVgpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMuZXhwb3J0cy5wdXNoKHJlcyk7XG4gICAgfVxuICB9XG5cbiAgdmlzaXRTb3VyY2Uobm9kZTogU291cmNlKTogdm9pZCB7XG4gICAgc3VwZXIudmlzaXRTb3VyY2Uobm9kZSk7XG4gICAgY29uc3QgbmV3UGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIGNvbnN0IGxhc3RTdGF0ZW1lbnQgPVxuICAgICAgKG5vZGUuc3RhdGVtZW50cy5sZW5ndGggJiYgbm9kZS5zdGF0ZW1lbnRzW25vZGUuc3RhdGVtZW50cy5sZW5ndGggLSAxXSkgfHxcbiAgICAgIG5vZGU7XG4gICAgaWYgKHRoaXMuZnVuY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuc3RhdGVtZW50cy5wdXNoKFxuICAgICAgICAuLi50aGlzLmZ1bmN0aW9ucy5tYXAoKG4pID0+IFJhbmdlVHJhbnNmb3JtLnZpc2l0KG4sIGxhc3RTdGF0ZW1lbnQpKVxuICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RyID0gdGhpcy5leHBvcnRzLmpvaW4oXCJcXG5cIik7XG4gICAgICBuZXdQYXJzZXIucGFyc2VGaWxlKHN0ciwgbm9kZS5ub3JtYWxpemVkUGF0aCwgaXNFbnRyeShub2RlKSk7XG4gICAgICBjb25zdCBleHBvcnRzU291cmNlID0gbmV3UGFyc2VyLnNvdXJjZXNbMF07XG4gICAgICBub2RlLnN0YXRlbWVudHMgPSBub2RlLnN0YXRlbWVudHMuY29uY2F0KGV4cG9ydHNTb3VyY2Uuc3RhdGVtZW50cyk7XG4gICAgICBub2RlLnN0YXRlbWVudHMucHVzaCguLi50aGlzLmNsYXNzV3JhcHBlcnMpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyB2aXNpdChzb3VyY2VzOiBTb3VyY2VbXSk6IHZvaWQge1xuICAgIEZ1bmN0aW9uRXhwb3J0V3JhcHBlci5jaGVja1Rlc3RCdWlsZChzb3VyY2VzKTtcbiAgICBzb3VyY2VzLmZvckVhY2goKHMpID0+IHtcbiAgICAgIG5ldyBGdW5jdGlvbkV4cG9ydFdyYXBwZXIoKS52aXNpdChzKTtcbiAgICB9KTtcbiAgfVxufVxuIl19