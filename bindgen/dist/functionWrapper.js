"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionExportWrapper = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const common_1 = require("./common");
const utils_1 = require("./utils");
const transformRange_1 = require("visitor-as/dist/transformRange");
class FunctionExportWrapper extends visitor_as_1.BaseVisitor {
    constructor() {
        super(...arguments);
        this.functions = [];
        this.exports = [];
        this.wrappedFuncs = new Set();
    }
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes(".spec."));
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has(utils_1.toString(node.name));
        let noInputOrOutput = common_1.numOfParameters(node) == 0 && common_1.returnsVoid(node);
        if (!isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            FunctionExportWrapper.isTest)
            return false;
        return common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        const name = utils_1.getName(node);
        if (!this.needsWrapper(node)) {
            if ((common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR)) &&
                !this.wrappedFuncs.has(name) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                this.exports.push(this.camelCaseToSnakeCaseExport(name, ""));
                this.wrappedFuncs.add(name);
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        this.functions.push(common_1.parseTopLevelStatements(this.generateWrapperFunction(node))[0]);
        console.log(visitor_as_1.utils.toString(this.functions[this.functions.length - 1]));
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(name);
    }
    camelCaseToSnakeCaseExport(name, prefix = common_1.WRAPPER_PREFIX) {
        let s = utils_1.makeSnakeCase(name);
        if (s.normalize() === name.normalize()) {
            return "";
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let funcSource = [];
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = utils_1.toString(returnType);
        let returnTypeNameNoNull = returnTypeName
            .split("|")
            .map((name) => name.trim())
            .filter((name) => name !== "null")
            .join("");
        let hasNull = returnTypeName.includes("null");
        let name = utils_1.getName(func);
        if (func.decorators && func.decorators.length > 0) {
            funcSource.push(func.decorators.map((decorator) => utils_1.toString(decorator)).join("\n"));
        }
        funcSource.push(`function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            funcSource.push(`  const obj = getInput();`);
        }
        if (returnTypeName !== "void") {
            funcSource.push(`  let result: ${returnTypeName} = ${name}(`);
        }
        else {
            funcSource.push(`  ${name}(`);
        }
        if (params.length > 0) {
            funcSource[funcSource.length - 1] += params
                .map((param) => {
                let name = utils_1.toString(param.name);
                let type = utils_1.toString(param.type);
                let res = `obj.has('${name}') ?
             ${common_1.createDecodeStatement(param)} : ${param.initializer
                    ? utils_1.toString(param.initializer)
                    : `requireParameter<${type}>("${name}")`}`;
                return res;
            })
                .join(",\n    ");
        }
        funcSource[funcSource.length - 1] += ");";
        if (returnTypeName !== "void") {
            funcSource.push(`  const val = encode<${returnTypeNameNoNull}>(${hasNull ? `changetype<${returnTypeNameNoNull}>(result)` : "result"});
  value_return(val.byteLength, val.dataStart);
  `);
        }
        funcSource.push(`}`);
        this.exports.push(`
export { ${common_1.WRAPPER_PREFIX + name} as ${name} }
${this.camelCaseToSnakeCaseExport(name)}
`);
        return funcSource.join("\n");
    }
    visitSource(node) {
        this.functions = [];
        this.exports = [];
        // console.log(this.functions.join("\n"))
        console.log(this.exports.join("\n"));
        super.visitSource(node);
        // const newCode = this.functions.join("\n")
        if (this.functions) {
            node.statements.push(...(this.functions.map((n) => transformRange_1.RangeTransform.visit(n, node))));
        }
    }
    static visit(sources) {
        FunctionExportWrapper.checkTestBuild(sources);
        (new FunctionExportWrapper()).visit(sources);
    }
}
exports.FunctionExportWrapper = FunctionExportWrapper;
FunctionExportWrapper.isTest = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25XcmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Z1bmN0aW9uV3JhcHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxzQ0FVdUI7QUFDdkIsMkNBQWdEO0FBQ2hELHFDQUFpSjtBQUNqSixtQ0FBMkQ7QUFDM0QsbUVBQStEO0FBRS9ELE1BQWEscUJBQXNCLFNBQVEsd0JBQVc7SUFBdEQ7O1FBQ0UsY0FBUyxHQUFnQixFQUFFLENBQUM7UUFDNUIsWUFBTyxHQUFhLEVBQUUsQ0FBQztRQUV2QixpQkFBWSxHQUFnQixJQUFJLEdBQUcsRUFBRSxDQUFDO0lBa0l4QyxDQUFDO0lBaElDLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBaUI7UUFDckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxZQUFZLENBQUMsSUFBeUI7UUFDcEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNDLElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLGdCQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDaEUsSUFBSSxlQUFlLEdBQUcsd0JBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksb0JBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RSxJQUNFLENBQUMsUUFBUTtZQUNULGNBQWM7WUFDZCxlQUFlO1lBQ2YscUJBQXFCLENBQUMsTUFBTTtZQUU1QixPQUFPLEtBQUssQ0FBQztRQUNmLE9BQU8sZ0JBQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxrQkFBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO0lBQ25FLENBQUM7SUFFRCx3QkFBd0IsQ0FBQyxJQUF5QjtRQUNoRCxNQUFNLElBQUksR0FBRyxlQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsSUFDRSxDQUFDLGdCQUFPLENBQUMsSUFBSSxDQUFDLElBQUksa0JBQUssQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLHVCQUFjLENBQUMsQ0FBQztnQkFDM0QsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7Z0JBQzVCLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQVcsQ0FBQyxNQUFNLENBQUMsRUFDM0I7Z0JBQ0EsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUM3RCxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM3QjtZQUNELEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyQyxPQUFPO1NBQ1I7UUFDRCxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxnQ0FBdUIsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BGLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7UUFDckUsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBVyxDQUFDLE1BQU0sQ0FBQztRQUM3QyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQsMEJBQTBCLENBQ3hCLElBQVksRUFDWixTQUFpQix1QkFBYztRQUUvQixJQUFJLENBQUMsR0FBRyxxQkFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRSxLQUFLLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUN0QyxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsT0FBTyxZQUFZLE1BQU0sR0FBRyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUM7SUFDL0MsQ0FBQztJQUVEOztNQUVFO0lBQ00sdUJBQXVCLENBQUMsSUFBeUI7UUFDdkQsSUFBSSxVQUFVLEdBQWEsRUFBRSxDQUFDO1FBQzlCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDL0IsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLFVBQVUsQ0FBQztRQUNsQyxJQUFJLFVBQVUsR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDO1FBQ3RDLElBQUksY0FBYyxHQUFHLGdCQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUMsSUFBSSxvQkFBb0IsR0FBRyxjQUFjO2FBQ3RDLEtBQUssQ0FBQyxHQUFHLENBQUM7YUFDVixHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUMxQixNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUM7YUFDakMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ1osSUFBSSxPQUFPLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxJQUFJLElBQUksR0FBRyxlQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNqRCxVQUFVLENBQUMsSUFBSSxDQUNiLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxnQkFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUNuRSxDQUFDO1NBQ0g7UUFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLHNCQUFzQixJQUFJLFlBQVksQ0FBQyxDQUFDO1FBQ3hELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsVUFBVSxDQUFDLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQzlDO1FBQ0QsSUFBSSxjQUFjLEtBQUssTUFBTSxFQUFFO1lBQzdCLFVBQVUsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLGNBQWMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDO1NBQy9EO2FBQU07WUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxHQUFHLENBQUMsQ0FBQztTQUMvQjtRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTTtpQkFDeEMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ2IsSUFBSSxJQUFJLEdBQUcsZ0JBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ2hDLElBQUksSUFBSSxHQUFHLGdCQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNoQyxJQUFJLEdBQUcsR0FBRyxZQUFZLElBQUk7ZUFDckIsOEJBQXFCLENBQUMsS0FBSyxDQUFDLE1BQy9CLEtBQUssQ0FBQyxXQUFXO29CQUNmLENBQUMsQ0FBQyxnQkFBUSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7b0JBQzdCLENBQUMsQ0FBQyxvQkFBb0IsSUFBSSxNQUFNLElBQUksSUFDeEMsRUFBRSxDQUFDO2dCQUNILE9BQU8sR0FBRyxDQUFDO1lBQ2IsQ0FBQyxDQUFDO2lCQUNELElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUNwQjtRQUNELFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQztRQUMxQyxJQUFJLGNBQWMsS0FBSyxNQUFNLEVBQUU7WUFDN0IsVUFBVSxDQUFDLElBQUksQ0FBQyx3QkFBd0Isb0JBQW9CLEtBQzFELE9BQU8sQ0FBQyxDQUFDLENBQUMsY0FBYyxvQkFBb0IsV0FBVyxDQUFDLENBQUMsQ0FBQyxRQUM1RDs7R0FFSCxDQUFDLENBQUM7U0FDQTtRQUNELFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7UUFDcEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7V0FDWCx1QkFBYyxHQUFHLElBQUksT0FBTyxJQUFJO0VBQ3pDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxJQUFJLENBQUM7Q0FDdEMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCxXQUFXLENBQUMsSUFBWTtRQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUNwQixJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztRQUNsQix5Q0FBeUM7UUFDekMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFBO1FBQ3BDLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEIsNENBQTRDO1FBQzVDLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNsQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFFLCtCQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQTtTQUNyRjtJQUVILENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWlCO1FBQzVCLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxDQUFDLElBQUkscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvQyxDQUFDOztBQXJJSCxzREFzSUM7QUFuSVEsNEJBQU0sR0FBWSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDbGFzc0RlY2xhcmF0aW9uLFxuICBGaWVsZERlY2xhcmF0aW9uLFxuICBNZXRob2REZWNsYXJhdGlvbixcbiAgU291cmNlLFxuICBDb21tb25GbGFncyxcbiAgU291cmNlS2luZCxcbiAgRnVuY3Rpb25EZWNsYXJhdGlvbixcbiAgQmxvY2tTdGF0ZW1lbnQsXG4gIFN0YXRlbWVudCxcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IHV0aWxzLCBCYXNlVmlzaXRvciB9IGZyb20gXCJ2aXNpdG9yLWFzXCI7XG5pbXBvcnQgeyBjcmVhdGVEZWNvZGVTdGF0ZW1lbnQsIGlzRW50cnksIE5FQVJfREVDT1JBVE9SLCBudW1PZlBhcmFtZXRlcnMsIHBhcnNlVG9wTGV2ZWxTdGF0ZW1lbnRzLCByZXR1cm5zVm9pZCwgV1JBUFBFUl9QUkVGSVggfSBmcm9tIFwiLi9jb21tb25cIjtcbmltcG9ydCB7IGdldE5hbWUsIG1ha2VTbmFrZUNhc2UsIHRvU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IFJhbmdlVHJhbnNmb3JtIH0gZnJvbSBcInZpc2l0b3ItYXMvZGlzdC90cmFuc2Zvcm1SYW5nZVwiXG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkV4cG9ydFdyYXBwZXIgZXh0ZW5kcyBCYXNlVmlzaXRvciB7XG4gIGZ1bmN0aW9uczogU3RhdGVtZW50W10gPSBbXTtcbiAgZXhwb3J0czogc3RyaW5nW10gPSBbXTtcbiAgc3RhdGljIGlzVGVzdDogYm9vbGVhbiA9IGZhbHNlO1xuICB3cmFwcGVkRnVuY3M6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gIHN0YXRpYyBjaGVja1Rlc3RCdWlsZChzb3VyY2VzOiBTb3VyY2VbXSkge1xuICAgIHRoaXMuaXNUZXN0ID0gc291cmNlcy5zb21lKChzKSA9PiBzLm5vcm1hbGl6ZWRQYXRoLmluY2x1ZGVzKFwiLnNwZWMuXCIpKTtcbiAgfVxuXG4gIG5lZWRzV3JhcHBlcihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogYm9vbGVhbiB7XG4gICAgbGV0IGlzRXhwb3J0ID0gbm9kZS5pcyhDb21tb25GbGFncy5FWFBPUlQpO1xuICAgIGxldCBhbHJlYWR5V3JhcHBlZCA9IHRoaXMud3JhcHBlZEZ1bmNzLmhhcyh0b1N0cmluZyhub2RlLm5hbWUpKTtcbiAgICBsZXQgbm9JbnB1dE9yT3V0cHV0ID0gbnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID09IDAgJiYgcmV0dXJuc1ZvaWQobm9kZSk7XG4gICAgaWYgKFxuICAgICAgIWlzRXhwb3J0IHx8XG4gICAgICBhbHJlYWR5V3JhcHBlZCB8fFxuICAgICAgbm9JbnB1dE9yT3V0cHV0IHx8XG4gICAgICBGdW5jdGlvbkV4cG9ydFdyYXBwZXIuaXNUZXN0XG4gICAgKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpc0VudHJ5KG5vZGUpIHx8IHV0aWxzLmhhc0RlY29yYXRvcihub2RlLCBORUFSX0RFQ09SQVRPUik7XG4gIH1cblxuICB2aXNpdEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IG5hbWUgPSBnZXROYW1lKG5vZGUpO1xuICAgIGlmICghdGhpcy5uZWVkc1dyYXBwZXIobm9kZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGlzRW50cnkobm9kZSkgfHwgdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIE5FQVJfREVDT1JBVE9SKSkgJiZcbiAgICAgICAgIXRoaXMud3JhcHBlZEZ1bmNzLmhhcyhuYW1lKSAmJlxuICAgICAgICBub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVClcbiAgICAgICkge1xuICAgICAgICB0aGlzLmV4cG9ydHMucHVzaCh0aGlzLmNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KG5hbWUsIFwiXCIpKTtcbiAgICAgICAgdGhpcy53cmFwcGVkRnVuY3MuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgICAgc3VwZXIudmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZ1bmN0aW9ucy5wdXNoKHBhcnNlVG9wTGV2ZWxTdGF0ZW1lbnRzKHRoaXMuZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24obm9kZSkpWzBdKTtcbiAgICBjb25zb2xlLmxvZyh1dGlscy50b1N0cmluZyh0aGlzLmZ1bmN0aW9uc1t0aGlzLmZ1bmN0aW9ucy5sZW5ndGggLTFdKSlcbiAgICAvLyBDaGFuZ2UgZnVuY3Rpb24gdG8gbm90IGJlIGFuIGV4cG9ydFxuICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZChuYW1lKTtcbiAgfVxuXG4gIGNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcmVmaXg6IHN0cmluZyA9IFdSQVBQRVJfUFJFRklYXG4gICk6IHN0cmluZyB7XG4gICAgbGV0IHMgPSBtYWtlU25ha2VDYXNlKG5hbWUpO1xuICAgIGlmIChzLm5vcm1hbGl6ZSgpID09PSBuYW1lLm5vcm1hbGl6ZSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBleHBvcnQgeyAke3ByZWZpeCArIG5hbWV9IGFzICR7c30gfWA7XG4gIH1cblxuICAvKlxuICBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleHBvcnQgaW4gdGhlIGZ1bmN0aW9uJ3MgcGxhY2UuXG4gICovXG4gIHByaXZhdGUgZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24oZnVuYzogRnVuY3Rpb25EZWNsYXJhdGlvbik6IHN0cmluZyB7XG4gICAgbGV0IGZ1bmNTb3VyY2U6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHNpZ25hdHVyZSA9IGZ1bmMuc2lnbmF0dXJlO1xuICAgIGxldCBwYXJhbXMgPSBzaWduYXR1cmUucGFyYW1ldGVycztcbiAgICBsZXQgcmV0dXJuVHlwZSA9IHNpZ25hdHVyZS5yZXR1cm5UeXBlO1xuICAgIGxldCByZXR1cm5UeXBlTmFtZSA9IHRvU3RyaW5nKHJldHVyblR5cGUpO1xuICAgIGxldCByZXR1cm5UeXBlTmFtZU5vTnVsbCA9IHJldHVyblR5cGVOYW1lXG4gICAgICAuc3BsaXQoXCJ8XCIpXG4gICAgICAubWFwKChuYW1lKSA9PiBuYW1lLnRyaW0oKSlcbiAgICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09IFwibnVsbFwiKVxuICAgICAgLmpvaW4oXCJcIik7XG4gICAgbGV0IGhhc051bGwgPSByZXR1cm5UeXBlTmFtZS5pbmNsdWRlcyhcIm51bGxcIik7XG4gICAgbGV0IG5hbWUgPSBnZXROYW1lKGZ1bmMpO1xuICAgIGlmIChmdW5jLmRlY29yYXRvcnMgJiYgZnVuYy5kZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZ1bmNTb3VyY2UucHVzaChcbiAgICAgICAgZnVuYy5kZWNvcmF0b3JzLm1hcCgoZGVjb3JhdG9yKSA9PiB0b1N0cmluZyhkZWNvcmF0b3IpKS5qb2luKFwiXFxuXCIpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jU291cmNlLnB1c2goYGZ1bmN0aW9uIF9fd3JhcHBlcl8ke25hbWV9KCk6IHZvaWQge2ApO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgZnVuY1NvdXJjZS5wdXNoKGAgIGNvbnN0IG9iaiA9IGdldElucHV0KCk7YCk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5UeXBlTmFtZSAhPT0gXCJ2b2lkXCIpIHtcbiAgICAgIGZ1bmNTb3VyY2UucHVzaChgICBsZXQgcmVzdWx0OiAke3JldHVyblR5cGVOYW1lfSA9ICR7bmFtZX0oYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmNTb3VyY2UucHVzaChgICAke25hbWV9KGApO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZ1bmNTb3VyY2VbZnVuY1NvdXJjZS5sZW5ndGggLSAxXSArPSBwYXJhbXNcbiAgICAgICAgLm1hcCgocGFyYW0pID0+IHtcbiAgICAgICAgICBsZXQgbmFtZSA9IHRvU3RyaW5nKHBhcmFtLm5hbWUpO1xuICAgICAgICAgIGxldCB0eXBlID0gdG9TdHJpbmcocGFyYW0udHlwZSk7XG4gICAgICAgICAgbGV0IHJlcyA9IGBvYmouaGFzKCcke25hbWV9JykgP1xuICAgICAgICAgICAgICR7Y3JlYXRlRGVjb2RlU3RhdGVtZW50KHBhcmFtKX0gOiAke1xuICAgICAgICAgICAgcGFyYW0uaW5pdGlhbGl6ZXJcbiAgICAgICAgICAgICAgPyB0b1N0cmluZyhwYXJhbS5pbml0aWFsaXplcilcbiAgICAgICAgICAgICAgOiBgcmVxdWlyZVBhcmFtZXRlcjwke3R5cGV9PihcIiR7bmFtZX1cIilgXG4gICAgICAgICAgfWA7XG4gICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCIsXFxuICAgIFwiKTtcbiAgICB9XG4gICAgZnVuY1NvdXJjZVtmdW5jU291cmNlLmxlbmd0aCAtIDFdICs9IFwiKTtcIjtcbiAgICBpZiAocmV0dXJuVHlwZU5hbWUgIT09IFwidm9pZFwiKSB7XG4gICAgICBmdW5jU291cmNlLnB1c2goYCAgY29uc3QgdmFsID0gZW5jb2RlPCR7cmV0dXJuVHlwZU5hbWVOb051bGx9Pigke1xuICAgICAgICBoYXNOdWxsID8gYGNoYW5nZXR5cGU8JHtyZXR1cm5UeXBlTmFtZU5vTnVsbH0+KHJlc3VsdClgIDogXCJyZXN1bHRcIlxuICAgICAgfSk7XG4gIHZhbHVlX3JldHVybih2YWwuYnl0ZUxlbmd0aCwgdmFsLmRhdGFTdGFydCk7XG4gIGApO1xuICAgIH1cbiAgICBmdW5jU291cmNlLnB1c2goYH1gKVxuICAgIHRoaXMuZXhwb3J0cy5wdXNoKGBcbmV4cG9ydCB7ICR7V1JBUFBFUl9QUkVGSVggKyBuYW1lfSBhcyAke25hbWV9IH1cbiR7dGhpcy5jYW1lbENhc2VUb1NuYWtlQ2FzZUV4cG9ydChuYW1lKX1cbmApO1xucmV0dXJuIGZ1bmNTb3VyY2Uuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHZpc2l0U291cmNlKG5vZGU6IFNvdXJjZSk6IHZvaWQge1xuICAgIHRoaXMuZnVuY3Rpb25zID0gW107XG4gICAgdGhpcy5leHBvcnRzID0gW107XG4gICAgLy8gY29uc29sZS5sb2codGhpcy5mdW5jdGlvbnMuam9pbihcIlxcblwiKSlcbiAgICBjb25zb2xlLmxvZyh0aGlzLmV4cG9ydHMuam9pbihcIlxcblwiKSlcbiAgICBzdXBlci52aXNpdFNvdXJjZShub2RlKTtcbiAgICAvLyBjb25zdCBuZXdDb2RlID0gdGhpcy5mdW5jdGlvbnMuam9pbihcIlxcblwiKVxuICAgIGlmICh0aGlzLmZ1bmN0aW9ucykge1xuICAgICAgbm9kZS5zdGF0ZW1lbnRzLnB1c2goLi4uKHRoaXMuZnVuY3Rpb25zLm1hcCgobikgPT4gIFJhbmdlVHJhbnNmb3JtLnZpc2l0KG4sIG5vZGUpKSkpXG4gICAgfVxuICAgIFxuICB9XG5cbiAgc3RhdGljIHZpc2l0KHNvdXJjZXM6IFNvdXJjZVtdKTogdm9pZCB7XG4gICAgRnVuY3Rpb25FeHBvcnRXcmFwcGVyLmNoZWNrVGVzdEJ1aWxkKHNvdXJjZXMpO1xuICAgIChuZXcgRnVuY3Rpb25FeHBvcnRXcmFwcGVyKCkpLnZpc2l0KHNvdXJjZXMpO1xuICB9XG59XG4iXX0=