"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionExportWrapper = exports.FunctionClass = void 0;
const as_1 = require("visitor-as/as");
const visitor_as_1 = require("visitor-as");
const common_1 = require("./common");
const utils_1 = require("./utils");
const transformRange_1 = require("visitor-as/dist/transformRange");
class FunctionClass extends visitor_as_1.BaseVisitor {
    _class;
    visitFunctionDeclaration(node) {
        let name = utils_1.getName(node);
        let fields = node.signature.parameters.map((p) => `${utils_1.toString(p.name)}: ${utils_1.getName(p.type)}`);
        let params = node.signature.parameters.map((p) => `this.${utils_1.getName(p)}`);
        if (fields.length > 0) {
            // add blank to make join add ;
            fields.push("");
        }
        const fieldStrs = fields.join(";\n");
        let _classStr = `class ${name}__class {
  ${fieldStrs}
  call(): ${utils_1.getTypeName(node.signature.returnType)} {
    ${common_1.returnsVoid(node) ? "" : "return "}${name}(${params.join(",")});
  }
}`;
        console.log(_classStr);
        let _class = (visitor_as_1.SimpleParser.parseTopLevelStatement(_classStr));
        // MethodInjector.visit(_class);
        this._class = _class;
    }
    static visit(node) {
        const funcClass = new FunctionClass();
        funcClass.visit(node);
        return funcClass._class;
    }
}
exports.FunctionClass = FunctionClass;
function emptySignature(node) {
    return common_1.numOfParameters(node) == 0 && common_1.returnsVoid(node);
}
class FunctionExportWrapper extends visitor_as_1.BaseVisitor {
    static isTest = false;
    functions = [];
    exports = [];
    wrappedFuncs = new Set();
    classWrappers = [];
    static checkTestBuild(sources) {
        this.isTest = sources.some((s) => s.normalizedPath.includes(".spec."));
    }
    needsWrapper(node) {
        let isExport = node.is(as_1.CommonFlags.EXPORT);
        let alreadyWrapped = this.wrappedFuncs.has(utils_1.toString(node.name));
        let noInputOrOutput = emptySignature(node);
        if (!isExport ||
            alreadyWrapped ||
            noInputOrOutput ||
            FunctionExportWrapper.isTest)
            return false;
        return common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR);
    }
    visitFunctionDeclaration(node) {
        const name = utils_1.toString(node.name);
        if (!this.needsWrapper(node)) {
            if ((common_1.isEntry(node) || visitor_as_1.utils.hasDecorator(node, common_1.NEAR_DECORATOR)) &&
                !this.wrappedFuncs.has(name) &&
                node.is(as_1.CommonFlags.EXPORT)) {
                const snakeCase = this.camelCaseToSnakeCaseExport(name, "");
                this.wrappedFuncs.add(name);
                if (snakeCase) {
                    this.exports.push(snakeCase);
                }
            }
            super.visitFunctionDeclaration(node);
            return;
        }
        if (common_1.numOfParameters(node) > 0) {
            const _class = FunctionClass.visit(node);
            transformRange_1.RangeTransform.visit(_class, node);
            this.classWrappers.push(_class);
        }
        this.functions.push(common_1.parseTopLevelStatements(this.generateWrapperFunction(node))[0]);
        // Change function to not be an export
        node.flags = node.flags ^ as_1.CommonFlags.EXPORT;
        this.wrappedFuncs.add(name);
    }
    camelCaseToSnakeCaseExport(name, prefix = common_1.WRAPPER_PREFIX) {
        let s = utils_1.makeSnakeCase(name);
        if (s.normalize() === name.normalize()) {
            return "";
        }
        return `export { ${prefix + name} as ${s} }`;
    }
    /*
    Create a wrapper function that will be export in the function's place.
    */
    generateWrapperFunction(func) {
        let funcSource = [];
        let signature = func.signature;
        let params = signature.parameters;
        let returnType = signature.returnType;
        let returnTypeName = utils_1.toString(returnType);
        let name = utils_1.getName(func);
        if (func.decorators && func.decorators.length > 0) {
            funcSource.push(func.decorators.map((decorator) => utils_1.toString(decorator)).join("\n"));
        }
        const className = name + "__class";
        funcSource.push(`
    function __wrapper_${name}(): void {`);
        if (params.length > 0) {
            funcSource.push(`  const _class = JSON.parse<${className}>(getInputString())`);
        }
        if (returnTypeName !== "void") {
            if (params.length > 0) {
                funcSource.push(`let result: ${returnTypeName} = _class.call();`);
            }
            else {
                funcSource.push(`let result: ${returnTypeName} = ${name}();`);
            }
            funcSource.push(`
      const val = String.UTF8.encode(JSON.stringify(result));
      value_return(val.byteLength, changetype<usize>(val));
  `);
        }
        else {
            if (params.length > 0) {
                funcSource.push(`_class.call()`);
            }
            else {
                funcSource.push(`${name}();`);
            }
        }
        funcSource.push(`}`);
        this.addExport(name);
        return funcSource.join("\n");
    }
    addExport(name) {
        this.exports.push(`export {${common_1.WRAPPER_PREFIX + name} as ${name}}`);
        let res = this.camelCaseToSnakeCaseExport(name, common_1.WRAPPER_PREFIX);
        if (res) {
            this.exports.push(res);
        }
    }
    visitSource(node) {
        super.visitSource(node);
        const newParser = new as_1.Parser();
        const lastStatement = node.statements.length && node.statements[node.statements.length - 1] || node;
        if (this.functions.length > 0) {
            node.statements.push(...this.functions.map((n) => transformRange_1.RangeTransform.visit(n, lastStatement)));
            const str = this.exports.join("\n");
            newParser.parseFile(str, node.normalizedPath, common_1.isEntry(node));
            const exportsSource = newParser.sources[0];
            node.statements = node.statements.concat(exportsSource.statements);
            node.statements.push(...this.classWrappers);
        }
    }
    static visit(sources) {
        FunctionExportWrapper.checkTestBuild(sources);
        sources.forEach((s) => {
            new FunctionExportWrapper().visit(s);
        });
    }
}
exports.FunctionExportWrapper = FunctionExportWrapper;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25XcmFwcGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Z1bmN0aW9uV3JhcHBlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxzQ0FTdUI7QUFDdkIsMkNBQThEO0FBQzlELHFDQVFrQjtBQUNsQixtQ0FBd0U7QUFDeEUsbUVBQWdFO0FBSWhFLE1BQWEsYUFBYyxTQUFRLHdCQUFXO0lBQzVDLE1BQU0sQ0FBbUI7SUFFekIsd0JBQXdCLENBQUMsSUFBeUI7UUFDaEQsSUFBSSxJQUFJLEdBQUcsZUFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxnQkFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxlQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM3RixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLFFBQVEsZUFBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN4RSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3JCLCtCQUErQjtZQUMvQixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2pCO1FBRUQsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQyxJQUFJLFNBQVMsR0FBRyxTQUFTLElBQUk7SUFDN0IsU0FBUztZQUNELG1CQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUM7TUFDNUMsb0JBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMs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TSxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLGNBQWMsRUFBRSxnQkFBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDN0QsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUMzQyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNuRSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUM3QztJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQWlCO1FBQzVCLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDcEIsSUFBSSxxQkFBcUIsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7O0FBcEpILHNEQXFKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENsYXNzRGVjbGFyYXRpb24sXG4gIFNvdXJjZSxcbiAgQ29tbW9uRmxhZ3MsXG4gIEZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gIFN0YXRlbWVudCxcbiAgUHJvZ3JhbSxcbiAgTm9kZUtpbmQsXG4gIFBhcnNlcixcbn0gZnJvbSBcInZpc2l0b3ItYXMvYXNcIjtcbmltcG9ydCB7IHV0aWxzLCBCYXNlVmlzaXRvciwgU2ltcGxlUGFyc2VyIH0gZnJvbSBcInZpc2l0b3ItYXNcIjtcbmltcG9ydCB7XG4gIGNyZWF0ZURlY29kZVN0YXRlbWVudCxcbiAgaXNFbnRyeSxcbiAgTkVBUl9ERUNPUkFUT1IsXG4gIG51bU9mUGFyYW1ldGVycyxcbiAgcGFyc2VUb3BMZXZlbFN0YXRlbWVudHMsXG4gIHJldHVybnNWb2lkLFxuICBXUkFQUEVSX1BSRUZJWCxcbn0gZnJvbSBcIi4vY29tbW9uXCI7XG5pbXBvcnQgeyBnZXROYW1lLCBnZXRUeXBlTmFtZSwgbWFrZVNuYWtlQ2FzZSwgdG9TdHJpbmcgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgUmFuZ2VUcmFuc2Zvcm0gfSBmcm9tIFwidmlzaXRvci1hcy9kaXN0L3RyYW5zZm9ybVJhbmdlXCI7XG5pbXBvcnQgeyBNZXRob2RJbmplY3RvciB9IGZyb20gXCJAc2VyaWFsLWFzL3RyYW5zZm9ybS9kaXN0L21ldGhvZEluamVjdG9yXCI7XG5pbXBvcnQgeyBpc0xpYnJhcnkgfSBmcm9tIFwidmlzaXRvci1hcy9kaXN0L3V0aWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbkNsYXNzIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xuICBfY2xhc3M6IENsYXNzRGVjbGFyYXRpb247XG5cbiAgdmlzaXRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiB2b2lkIHtcbiAgICBsZXQgbmFtZSA9IGdldE5hbWUobm9kZSk7XG4gICAgbGV0IGZpZWxkcyA9IG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubWFwKChwKSA9PiBgJHt0b1N0cmluZyhwLm5hbWUpfTogJHtnZXROYW1lKHAudHlwZSl9YCk7XG4gICAgbGV0IHBhcmFtcyA9IG5vZGUuc2lnbmF0dXJlLnBhcmFtZXRlcnMubWFwKChwKSA9PiBgdGhpcy4ke2dldE5hbWUocCl9YCk7XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBhZGQgYmxhbmsgdG8gbWFrZSBqb2luIGFkZCA7XG4gICAgICBmaWVsZHMucHVzaChcIlwiKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmllbGRTdHJzID0gZmllbGRzLmpvaW4oXCI7XFxuXCIpO1xuICAgIGxldCBfY2xhc3NTdHIgPSBgY2xhc3MgJHtuYW1lfV9fY2xhc3Mge1xuICAke2ZpZWxkU3Ryc31cbiAgY2FsbCgpOiAke2dldFR5cGVOYW1lKG5vZGUuc2lnbmF0dXJlLnJldHVyblR5cGUpfSB7XG4gICAgJHtyZXR1cm5zVm9pZChub2RlKSA/IFwiXCIgOiBcInJldHVybiBcIn0ke25hbWV9KCR7cGFyYW1zLmpvaW4oXCIsXCIpfSk7XG4gIH1cbn1gO1xuICBjb25zb2xlLmxvZyhfY2xhc3NTdHIpXG4gICAgbGV0IF9jbGFzcyA9IDxDbGFzc0RlY2xhcmF0aW9uPihcbiAgICAgIFNpbXBsZVBhcnNlci5wYXJzZVRvcExldmVsU3RhdGVtZW50KF9jbGFzc1N0cilcbiAgICApO1xuICAgIC8vIE1ldGhvZEluamVjdG9yLnZpc2l0KF9jbGFzcyk7XG4gICAgdGhpcy5fY2xhc3MgPSBfY2xhc3M7XG4gIH1cblxuICBzdGF0aWMgdmlzaXQobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IENsYXNzRGVjbGFyYXRpb24ge1xuICAgIGNvbnN0IGZ1bmNDbGFzcyA9IG5ldyBGdW5jdGlvbkNsYXNzKCk7XG4gICAgZnVuY0NsYXNzLnZpc2l0KG5vZGUpO1xuICAgIHJldHVybiBmdW5jQ2xhc3MuX2NsYXNzO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZW1wdHlTaWduYXR1cmUobm9kZTogRnVuY3Rpb25EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gbnVtT2ZQYXJhbWV0ZXJzKG5vZGUpID09IDAgJiYgcmV0dXJuc1ZvaWQobm9kZSk7XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25FeHBvcnRXcmFwcGVyIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xuICBzdGF0aWMgaXNUZXN0OiBib29sZWFuID0gZmFsc2U7XG4gIGZ1bmN0aW9uczogU3RhdGVtZW50W10gPSBbXTtcbiAgZXhwb3J0czogc3RyaW5nW10gPSBbXTtcbiAgd3JhcHBlZEZ1bmNzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKTtcbiAgY2xhc3NXcmFwcGVyczogQ2xhc3NEZWNsYXJhdGlvbltdID0gW107XG5cbiAgc3RhdGljIGNoZWNrVGVzdEJ1aWxkKHNvdXJjZXM6IFNvdXJjZVtdKSB7XG4gICAgdGhpcy5pc1Rlc3QgPSBzb3VyY2VzLnNvbWUoKHMpID0+IHMubm9ybWFsaXplZFBhdGguaW5jbHVkZXMoXCIuc3BlYy5cIikpO1xuICB9XG5cbiAgbmVlZHNXcmFwcGVyKG5vZGU6IEZ1bmN0aW9uRGVjbGFyYXRpb24pOiBib29sZWFuIHtcbiAgICBsZXQgaXNFeHBvcnQgPSBub2RlLmlzKENvbW1vbkZsYWdzLkVYUE9SVCk7XG4gICAgbGV0IGFscmVhZHlXcmFwcGVkID0gdGhpcy53cmFwcGVkRnVuY3MuaGFzKHRvU3RyaW5nKG5vZGUubmFtZSkpO1xuICAgIGxldCBub0lucHV0T3JPdXRwdXQgPSBlbXB0eVNpZ25hdHVyZShub2RlKTtcbiAgICBpZiAoXG4gICAgICAhaXNFeHBvcnQgfHxcbiAgICAgIGFscmVhZHlXcmFwcGVkIHx8XG4gICAgICBub0lucHV0T3JPdXRwdXQgfHxcbiAgICAgIEZ1bmN0aW9uRXhwb3J0V3JhcHBlci5pc1Rlc3RcbiAgICApXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGlzRW50cnkobm9kZSkgfHwgdXRpbHMuaGFzRGVjb3JhdG9yKG5vZGUsIE5FQVJfREVDT1JBVE9SKTtcbiAgfVxuXG4gIHZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlOiBGdW5jdGlvbkRlY2xhcmF0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgbmFtZSA9IHRvU3RyaW5nKG5vZGUubmFtZSk7XG4gICAgaWYgKCF0aGlzLm5lZWRzV3JhcHBlcihub2RlKSkge1xuICAgICAgaWYgKFxuICAgICAgICAoaXNFbnRyeShub2RlKSB8fCB1dGlscy5oYXNEZWNvcmF0b3Iobm9kZSwgTkVBUl9ERUNPUkFUT1IpKSAmJlxuICAgICAgICAhdGhpcy53cmFwcGVkRnVuY3MuaGFzKG5hbWUpICYmXG4gICAgICAgIG5vZGUuaXMoQ29tbW9uRmxhZ3MuRVhQT1JUKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHNuYWtlQ2FzZSA9IHRoaXMuY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQobmFtZSwgXCJcIik7XG4gICAgICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZChuYW1lKTtcbiAgICAgICAgaWYgKHNuYWtlQ2FzZSkge1xuICAgICAgICAgIHRoaXMuZXhwb3J0cy5wdXNoKHNuYWtlQ2FzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1cGVyLnZpc2l0RnVuY3Rpb25EZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG51bU9mUGFyYW1ldGVycyhub2RlKSA+IDApIHtcbiAgICAgIGNvbnN0IF9jbGFzcyA9IEZ1bmN0aW9uQ2xhc3MudmlzaXQobm9kZSk7XG4gICAgICBSYW5nZVRyYW5zZm9ybS52aXNpdChfY2xhc3MsIG5vZGUpO1xuICAgICAgdGhpcy5jbGFzc1dyYXBwZXJzLnB1c2goX2NsYXNzKTtcbiAgICB9XG4gICAgdGhpcy5mdW5jdGlvbnMucHVzaChcbiAgICAgIHBhcnNlVG9wTGV2ZWxTdGF0ZW1lbnRzKHRoaXMuZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24obm9kZSkpWzBdXG4gICAgKTtcbiAgICAvLyBDaGFuZ2UgZnVuY3Rpb24gdG8gbm90IGJlIGFuIGV4cG9ydFxuICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzIF4gQ29tbW9uRmxhZ3MuRVhQT1JUO1xuICAgIHRoaXMud3JhcHBlZEZ1bmNzLmFkZChuYW1lKTtcbiAgfVxuXG4gIGNhbWVsQ2FzZVRvU25ha2VDYXNlRXhwb3J0KFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBwcmVmaXg6IHN0cmluZyA9IFdSQVBQRVJfUFJFRklYXG4gICk6IHN0cmluZyB7XG4gICAgbGV0IHMgPSBtYWtlU25ha2VDYXNlKG5hbWUpO1xuICAgIGlmIChzLm5vcm1hbGl6ZSgpID09PSBuYW1lLm5vcm1hbGl6ZSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBleHBvcnQgeyAke3ByZWZpeCArIG5hbWV9IGFzICR7c30gfWA7XG4gIH1cblxuICAvKlxuICBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleHBvcnQgaW4gdGhlIGZ1bmN0aW9uJ3MgcGxhY2UuXG4gICovXG4gIHByaXZhdGUgZ2VuZXJhdGVXcmFwcGVyRnVuY3Rpb24oZnVuYzogRnVuY3Rpb25EZWNsYXJhdGlvbik6IHN0cmluZyB7XG4gICAgbGV0IGZ1bmNTb3VyY2U6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHNpZ25hdHVyZSA9IGZ1bmMuc2lnbmF0dXJlO1xuICAgIGxldCBwYXJhbXMgPSBzaWduYXR1cmUucGFyYW1ldGVycztcbiAgICBsZXQgcmV0dXJuVHlwZSA9IHNpZ25hdHVyZS5yZXR1cm5UeXBlO1xuICAgIGxldCByZXR1cm5UeXBlTmFtZSA9IHRvU3RyaW5nKHJldHVyblR5cGUpO1xuICAgIGxldCBuYW1lID0gZ2V0TmFtZShmdW5jKTtcbiAgICBpZiAoZnVuYy5kZWNvcmF0b3JzICYmIGZ1bmMuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICBmdW5jU291cmNlLnB1c2goXG4gICAgICAgIGZ1bmMuZGVjb3JhdG9ycy5tYXAoKGRlY29yYXRvcikgPT4gdG9TdHJpbmcoZGVjb3JhdG9yKSkuam9pbihcIlxcblwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgY2xhc3NOYW1lID0gbmFtZSArIFwiX19jbGFzc1wiO1xuICAgIGZ1bmNTb3VyY2UucHVzaChgXG4gICAgZnVuY3Rpb24gX193cmFwcGVyXyR7bmFtZX0oKTogdm9pZCB7YCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBmdW5jU291cmNlLnB1c2goXG4gICAgICAgIGAgIGNvbnN0IF9jbGFzcyA9IEpTT04ucGFyc2U8JHtjbGFzc05hbWV9PihnZXRJbnB1dFN0cmluZygpKWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5UeXBlTmFtZSAhPT0gXCJ2b2lkXCIpIHtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmdW5jU291cmNlLnB1c2goXG4gICAgICAgICAgYGxldCByZXN1bHQ6ICR7cmV0dXJuVHlwZU5hbWV9ID0gX2NsYXNzLmNhbGwoKTtgXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmNTb3VyY2UucHVzaChcbiAgICAgICAgICBgbGV0IHJlc3VsdDogJHtyZXR1cm5UeXBlTmFtZX0gPSAke25hbWV9KCk7YFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBmdW5jU291cmNlLnB1c2goYFxuICAgICAgY29uc3QgdmFsID0gU3RyaW5nLlVURjguZW5jb2RlKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgdmFsdWVfcmV0dXJuKHZhbC5ieXRlTGVuZ3RoLCBjaGFuZ2V0eXBlPHVzaXplPih2YWwpKTtcbiAgYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmdW5jU291cmNlLnB1c2goYF9jbGFzcy5jYWxsKClgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmNTb3VyY2UucHVzaChcbiAgICAgICAgICBgJHtuYW1lfSgpO2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jU291cmNlLnB1c2goYH1gKTtcbiAgICB0aGlzLmFkZEV4cG9ydChuYW1lKTtcbiAgICByZXR1cm4gZnVuY1NvdXJjZS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgYWRkRXhwb3J0KG5hbWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgdGhpcy5leHBvcnRzLnB1c2goYGV4cG9ydCB7JHtXUkFQUEVSX1BSRUZJWCArIG5hbWV9IGFzICR7bmFtZX19YCk7XG4gICAgbGV0IHJlcyA9IHRoaXMuY2FtZWxDYXNlVG9TbmFrZUNhc2VFeHBvcnQobmFtZSwgV1JBUFBFUl9QUkVGSVgpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHRoaXMuZXhwb3J0cy5wdXNoKHJlcyk7XG4gICAgfVxuICB9XG5cbiAgdmlzaXRTb3VyY2Uobm9kZTogU291cmNlKTogdm9pZCB7XG4gICAgc3VwZXIudmlzaXRTb3VyY2Uobm9kZSk7XG4gICAgY29uc3QgbmV3UGFyc2VyID0gbmV3IFBhcnNlcigpO1xuICAgIGNvbnN0IGxhc3RTdGF0ZW1lbnQgPSBub2RlLnN0YXRlbWVudHMubGVuZ3RoICYmIG5vZGUuc3RhdGVtZW50c1tub2RlLnN0YXRlbWVudHMubGVuZ3RoIC0gMV0gfHwgbm9kZTtcbiAgICBpZiAodGhpcy5mdW5jdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5zdGF0ZW1lbnRzLnB1c2goXG4gICAgICAgIC4uLnRoaXMuZnVuY3Rpb25zLm1hcCgobikgPT4gUmFuZ2VUcmFuc2Zvcm0udmlzaXQobiwgbGFzdFN0YXRlbWVudCkpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdHIgPSB0aGlzLmV4cG9ydHMuam9pbihcIlxcblwiKTtcbiAgICAgIG5ld1BhcnNlci5wYXJzZUZpbGUoc3RyLCBub2RlLm5vcm1hbGl6ZWRQYXRoLCBpc0VudHJ5KG5vZGUpKTtcbiAgICAgIGNvbnN0IGV4cG9ydHNTb3VyY2UgPSBuZXdQYXJzZXIuc291cmNlc1swXTtcbiAgICAgIG5vZGUuc3RhdGVtZW50cyA9IG5vZGUuc3RhdGVtZW50cy5jb25jYXQoZXhwb3J0c1NvdXJjZS5zdGF0ZW1lbnRzKTtcbiAgICAgIG5vZGUuc3RhdGVtZW50cy5wdXNoKC4uLnRoaXMuY2xhc3NXcmFwcGVycyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHZpc2l0KHNvdXJjZXM6IFNvdXJjZVtdKTogdm9pZCB7XG4gICAgRnVuY3Rpb25FeHBvcnRXcmFwcGVyLmNoZWNrVGVzdEJ1aWxkKHNvdXJjZXMpO1xuICAgIHNvdXJjZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgbmV3IEZ1bmN0aW9uRXhwb3J0V3JhcHBlcigpLnZpc2l0KHMpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=